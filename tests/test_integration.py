# tests/test_integration.py
# ----------------------------------------------------------------------------------------------------
# “Integration” tests that exercise the public API surface of FastAPIKeycloak (idp) against a live
# Keycloak instance spun up by tests/conftest.py. These tests focus on read-only or idempotent
# operations and generic behaviors (timeouts, swagger config, discovery document, etc.).
#
# NOTES
# • The infrastructure (Keycloak + Postgres) is started before collection; see tests/conftest.py.
# • The realm and clients are provisioned from tests/realm-export.json (generated by build_realm.py).
# • We intentionally do not mutate persistent realm state here beyond harmless GETs and a
#   simulated timeout. CRUD-heavy scenarios live in tests/test_functional.py.
# • `httpretty` is imported for future HTTP mocking expansions but not used in the current suite.
# ----------------------------------------------------------------------------------------------------

from typing import List

import httpretty as httpretty  # noqa: F401 (present for future HTTP mocking)
import pytest as pytest
from fastapi import FastAPI
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError
from requests import ReadTimeout

from src.OSSS import HTTPMethod
from src.OSSS import KeycloakRole
from tests import BaseOSSSClass
import time  # noqa: F401 (kept for potential timing/debug additions)


class TestAPIIntegration(BaseOSSSClass):
    def test_properties(self, idp):
        """
        Sanity check: the Keycloak integration (`idp`) exposes all key properties.

        Why this matters:
        - These properties are the core “wiring” used by application code:
          * public_key             → JWK/PEM used to verify tokens
          * admin_token            → service-account token for admin-API calls
          * open_id_configuration  → OIDC discovery document (endpoints, issuer, etc.)
          * logout_uri/login_uri   → convenience URIs for browser redirects
          * roles_uri/token_uri/...→ stable base endpoints for admin/user ops
          * user_auth_scheme       → FastAPI security dependency (OAuth2PasswordBearer)
        """
        assert idp.public_key
        assert idp.admin_token
        assert idp.open_id_configuration
        assert idp.logout_uri
        assert idp.login_uri
        assert idp.roles_uri
        assert idp.token_uri
        assert idp.authorization_uri
        assert idp.user_auth_scheme
        assert idp.providers_uri
        assert idp.realm_uri
        assert idp.users_uri

    def test_admin_token(self, idp):
        """
        The admin token should be a valid JWT when fetched and reject invalid strings when set.

        Coverage:
        - Accessing `idp.admin_token` forces the integration to fetch/verify a token.
        - Assigning malformed tokens should raise jose.JWTError to signal invalid JWT structure.
        """
        # Valid token present (fetched during idp init)
        assert idp.admin_token

        # Invalid token: wrong number of segments (not header.payload.signature)
        with pytest.raises(JWTError):
            idp.admin_token = "some rubbish"

        # Invalid token: corrupted/invalid base64 padding or signature
        with pytest.raises(JWTError):
            idp.admin_token = """
            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
            """

    def test_add_swagger_config(self, idp):
        """
        The integration should enrich FastAPI’s Swagger UI with OAuth client settings.

        Behavior:
        - add_swagger_config(app) sets `swagger_ui_init_oauth` so that Swagger can perform
          the OAuth Authorization Code flow (with PKCE) using our configured client.
        """
        app = FastAPI()
        assert app.swagger_ui_init_oauth is None  # default

        idp.add_swagger_config(app)

        # After configuration, FastAPI will initialize the docs UI with these values
        assert app.swagger_ui_init_oauth == {
            "usePkceWithAuthorizationCodeGrant": True,
            "clientId": idp.client_id,
            "clientSecret": idp.client_secret,
        }

    def test_user_auth_scheme(self, idp):
        """
        FastAPIKeycloak exposes an OAuth2PasswordBearer so routes can use `Depends(idp.user_auth_scheme)`.

        This is a thin guard that ensures we’re wiring a standard FastAPI auth dependency.
        """
        assert isinstance(idp.user_auth_scheme, OAuth2PasswordBearer)

    def test_open_id_configuration(self, idp):
        """
        OIDC discovery should be reachable and parsed into a Python dict.

        This confirms Keycloak is up, the realm exists, and well-known metadata is available.
        """
        assert idp.open_id_configuration
        assert type(idp.open_id_configuration) == dict

    def test_proxy(self, idp):
        """
        `proxy` is a generic passthrough for relative admin-API calls.

        We call a harmless endpoint (`/realms/OSSS`) and assert:
        - The HTTP succeeds
        - The JSON payload is a dict (shape validated elsewhere)
        """
        response = idp.proxy(relative_path="/realms/OSSS", method=HTTPMethod.GET)
        assert type(response.json()) == dict

    def test_timeout(self, idp, monkeypatch):
        """
        Simulate an API call that exceeds the configured timeout and ensure a ReadTimeout is raised.

        Approach:
        - Monkeypatch `requests.request` to raise `ReadTimeout` only for `/timeout`.
        - Leave all other URLs to the real implementation so the rest of the suite remains normal.
        - Set a small `idp.timeout` just to highlight we honor the setting (even though the
          exception is forced here).
        """
        import requests
        real_request = requests.request

        def fake_request(method, url, *args, **kwargs):
            # Only simulate the timeout on the specific path we test below
            if url == f"{idp.server_url}/timeout":
                raise requests.exceptions.ReadTimeout("timed out")
            # Fall back to actual network behavior for everything else
            return real_request(method, url, *args, **kwargs)

        # Apply the monkeypatch and reduce the configured timeout to a small value
        monkeypatch.setattr(requests, "request", fake_request)
        idp.timeout = 0.5

        with pytest.raises(ReadTimeout):
            idp.proxy(relative_path="/timeout", method=HTTPMethod.GET)

    def test_get_all_roles_and_get_roles(self, idp):
        """
        Role listing should work, and looking up by names should return a 1:1 set.

        This verifies:
        - The admin token has enough privileges to list roles.
        - The helper `get_roles([...])` uses the same role names and returns the same count.
        """
        roles: List[KeycloakRole] = idp.get_all_roles()
        assert roles  # at least default-roles-test, offline_access, uma_authorization

        # Lookup all roles by their names
        lookup = idp.get_roles(role_names=[role.name for role in roles])
        assert lookup
        assert len(roles) == len(lookup)

    def test_get_identity_providers(self, idp):
        """
        In our test realm, no external IdPs are configured.

        This test guards the return type/shape and the “empty list” contract for clean realms.
        """
        assert idp.get_identity_providers() == []
