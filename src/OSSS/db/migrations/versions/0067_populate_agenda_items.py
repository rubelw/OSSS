"""Populate agenda_items from generated CSV (safe transactions + nullable binds + per-run regeneration)."""

from __future__ import annotations

import os, csv, logging, random
from pathlib import Path
from contextlib import nullcontext

from alembic import op
import sqlalchemy as sa

# ---- Alembic identifiers ----
revision = "0067_populate_agenda_items"
down_revision = "0066_populate_waivers"
branch_labels = None
depends_on = None

log = logging.getLogger("alembic.runtime.migration")

# ---- Config / env toggles ----------------------------------------------------
LOG_LVL        = os.getenv("AI_LOG_LEVEL", "INFO").upper()
LOG_SQL        = os.getenv("AI_LOG_SQL", "0") == "1"
LOG_ROWS       = os.getenv("AI_LOG_ROWS", "0") == "1"
ABORT_IF_ZERO  = os.getenv("AI_ABORT_IF_ZERO", "0") == "1"

CSV_ENV        = "AGENDA_ITEMS_CSV_PATH"
CSV_NAME       = "agenda_items.csv"
AI_ROWS        = int(os.getenv("AI_ROWS", "25"))
AI_SEED        = os.getenv("AI_SEED")

logging.getLogger("alembic.runtime.migration").setLevel(getattr(logging, LOG_LVL, logging.INFO))
engine_logger = logging.getLogger("sqlalchemy.engine")
engine_logger.setLevel(logging.INFO if LOG_SQL else getattr(logging, LOG_LVL, logging.INFO))

# ---- Tables ------------------------------------------------------------------
MEETINGS_TBL   = "meetings"
AGENDA_TBL     = "agenda_items"


# ---- Helpers -----------------------------------------------------------------
def _outer_tx(conn):
    """Open a transaction only if Alembic/engine hasn't already opened one."""
    try:
        if hasattr(conn, "get_transaction") and conn.get_transaction() is not None:
            return nullcontext()
        if hasattr(conn, "in_transaction") and conn.in_transaction():
            return nullcontext()
    except Exception:
        return nullcontext()
    return conn.begin()


def _default_output_path(name: str) -> Path:
    envp = os.getenv(CSV_ENV)
    if envp:
        p = Path(envp)
        return (p / name) if p.is_dir() else p
    return Path(__file__).resolve().with_name(name)


def _write_csv(bind) -> Path:
    """
    Always (re)write agenda_items.csv with AI_ROWS rows, sampling random meeting_id
    from the meetings table. If no meetings exist, write headers only.
    """
    out = _default_output_path(CSV_NAME)
    out.parent.mkdir(parents=True, exist_ok=True)

    meeting_ids = [str(r[0]) for r in bind.execute(sa.text(f"SELECT id FROM {MEETINGS_TBL} ORDER BY id")).fetchall()]
    if not meeting_ids:
        log.warning("[%s] No meetings found; writing header-only %s and skipping population.", revision, out)
        with out.open("w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["meeting_id","position","title","description","time_allocated"])
        return out

    rng = random.Random(AI_SEED)
    next_pos = {mid: 1 for mid in meeting_ids}

    with out.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["meeting_id","position","title","description","time_allocated"])
        for _ in range(AI_ROWS):
            mid = rng.choice(meeting_ids)
            pos = next_pos[mid]
            next_pos[mid] = pos + 1

            title = f"Auto Agenda Item #{pos} for meeting {mid[:8]}"
            desc  = "Seeded item generated by migration 0067."
            time_alloc = rng.choice([None, 5, 10, 15, 20, 30])

            w.writerow([mid, pos, title, desc, "" if time_alloc is None else time_alloc])

    log.info("[%s] wrote %d rows -> %s", revision, AI_ROWS, out)
    return out


def _open_csv(csv_path: Path):
    f = csv_path.open("r", encoding="utf-8", newline="")
    reader = csv.DictReader(f)
    log.info("[%s] CSV headers: %s (%s)", revision, reader.fieldnames, csv_path)
    return reader, f


# ---- Insert builder ----------------------------------------------------------
def _insert_sql(bind):
    insp = sa.inspect(bind)
    cols = {c["name"] for c in insp.get_columns(AGENDA_TBL)}

    ins_cols, vals = ["id"], ["gen_random_uuid()"]

    def add(col):
        if col in cols:
            ins_cols.append(col)
            vals.append(f":{col}")

    for c in ("meeting_id","parent_id","position","title","description",
              "linked_policy_id","linked_objective_id","time_allocated"):
        add(c)
    if "created_at" in cols: ins_cols.append("created_at"); vals.append("now()")
    if "updated_at" in cols: ins_cols.append("updated_at"); vals.append("now()")

    sql = sa.text(f"INSERT INTO {AGENDA_TBL} ({', '.join(ins_cols)}) VALUES ({', '.join(vals)})")
    return sql, cols


# ---- Migration ---------------------------------------------------------------
def upgrade() -> None:
    bind = op.get_bind()

    # Always (re)generate CSV on every run
    csv_path = _write_csv(bind)
    reader, fobj = _open_csv(csv_path)

    insert_stmt, cols = _insert_sql(bind)

    def _int_or_none(v):
        if v is None:
            return None
        if isinstance(v, int):
            return v
        s = str(v).strip()
        if s == "":
            return None
        try:
            return int(s)
        except ValueError:
            return None

    total = inserted = skipped = 0
    try:
        with _outer_tx(bind):
            for idx, raw in enumerate(reader, start=1):
                total += 1
                row = { (k.strip() if isinstance(k, str) else k): (v.strip() if isinstance(v, str) else v)
                        for k, v in (raw or {}).items() }

                meeting_id = row.get("meeting_id") or None
                title      = row.get("title") or None

                if not meeting_id or not title:
                    skipped += 1
                    if LOG_ROWS:
                        log.warning("[%s] row %d missing meeting_id/title â€” skipping: %r", revision, idx, row)
                    continue

                params = {
                    "meeting_id": meeting_id,
                    "parent_id": None,
                    "position": _int_or_none(row.get("position")) or 0,
                    "title": title,
                    "description": row.get("description") or None,
                    "linked_policy_id": None,
                    "linked_objective_id": None,
                    "time_allocated": _int_or_none(row.get("time_allocated")),
                }

                params = {k: v for k, v in params.items() if k in cols}

                try:
                    bind.execute(insert_stmt, params)
                    inserted += 1
                    if LOG_ROWS:
                        log.info("[%s] row %d INSERT ok (meeting_id=%s, title=%r)", revision, idx, meeting_id, title)
                except Exception:
                    skipped += 1
                    log.exception("[%s] row %d INSERT failed; params=%r", revision, idx, params)
    finally:
        try:
            fobj.close()
        except Exception:
            pass

    log.info("[%s] CSV rows=%d, inserted=%d, skipped=%d (file=%s)", revision, total, inserted, skipped, csv_path)
    if ABORT_IF_ZERO and inserted == 0:
        raise RuntimeError(f"[{revision}] No rows inserted; set AI_LOG_ROWS=1 to see per-row details.")


def downgrade() -> None:
    # Best-effort: delete only rows created by this seed (by our distinctive description)
    bind = op.get_bind()
    if sa.inspect(bind).has_table(AGENDA_TBL):
        try:
            res = bind.execute(sa.text(
                f"DELETE FROM {AGENDA_TBL} WHERE description = 'Seeded item generated by migration 0067.'"
            ))
            try:
                log.info("[%s] downgrade deleted %s seeded rows from %s", revision, res.rowcount, AGENDA_TBL)
            except Exception:
                pass
        except Exception:
            log.exception("[%s] downgrade best-effort delete failed", revision)
