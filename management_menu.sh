#!/usr/bin/env bash
# osss-compose-repair.sh
# Compose repair + Logs submenu (seed + non-seed shortcuts) with Ctrl-C back.

set -Eeuo pipefail

# -------- config / flags --------
PROJECT_DEFAULT="${COMPOSE_PROJECT_NAME:-osss}"
COMPOSE_FILE="${COMPOSE_FILE:-docker-compose.yml}"
PROFILE="${PROFILE:-seed}"

# persistent settings
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}"
CONFIG_FILE="${CONFIG_DIR}/osss-compose-repair.conf"
DEFAULT_TAIL="200"  # overridden by config file if present

usage() {
  cat <<EOF
Usage: $0 [-p PROJECT] [-f docker-compose.yml] [-r PROFILE]

Options:
  -p PROJECT      Compose project name (default: ${PROJECT_DEFAULT})
  -f FILE         Compose file path (default: ${COMPOSE_FILE})
  -r PROFILE      Compose profile to target (default: ${PROFILE})
EOF
  exit 0
}

while getopts ":p:f:r:h" opt; do
  case "$opt" in
    p) PROJECT_DEFAULT="$OPTARG" ;;
    f) COMPOSE_FILE="$OPTARG"   ;;
    r) PROFILE="$OPTARG"        ;;
    h) usage                    ;;
    \?) echo "Unknown option: -$OPTARG" >&2; usage ;;
  esac
done

export COMPOSE_PROJECT_NAME="${PROJECT_DEFAULT}"

# -------- helpers --------
compose_cmd() {
  if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
    echo "docker compose"
  elif command -v docker-compose >/dev/null 2>&1; then
    echo "docker-compose"
  else
    echo "âŒ Neither 'docker compose' nor 'docker-compose' found on PATH." >&2
    exit 1
  fi
}

ensure_compose_file() {
  if [[ ! -f "$COMPOSE_FILE" ]]; then
    echo "âŒ Compose file not found: $COMPOSE_FILE" >&2
    exit 1
  fi
}

run() { echo "+ $*"; "$@"; }

# project/profile-aware compose wrapper
c() { $COMPOSE -f "$COMPOSE_FILE" --profile "$PROFILE" "$@"; }

# config persistence
load_config() {
  mkdir -p "$CONFIG_DIR"
  [[ -f "$CONFIG_FILE" ]] && # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  : "${DEFAULT_TAIL:=${DEFAULT_TAIL:-200}}"
}
save_config() {
  {
    echo "# Auto-generated by osss-compose-repair.sh"
    echo "DEFAULT_TAIL=${DEFAULT_TAIL}"
  } > "$CONFIG_FILE"
  echo "Saved settings -> $CONFIG_FILE"
}

COMPOSE="$(compose_cmd)"
ensure_compose_file
load_config

# -------- actions --------
down_seed() { echo "â–¶ï¸  Bringing down profile '${PROFILE}' (remove orphans & volumes)â€¦"; run c down --remove-orphans --volumes || true; }
kill_leftovers() {
  echo "â–¶ï¸  Removing leftover containers for project '${COMPOSE_PROJECT_NAME}'â€¦"
  ids=$(docker ps -a --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" -q)
  if [[ -n "${ids:-}" ]]; then run docker rm -f ${ids}; else echo "(none)"; fi
}
prune_networks() { echo "â–¶ï¸  Pruning dangling networksâ€¦"; run docker network prune -f; }
rm_osss_networks() {
  echo "â–¶ï¸  Removing '${COMPOSE_PROJECT_NAME}_â€¦' networksâ€¦"
  nets=$(docker network ls --format '{{.Name}}' | grep -E "^${COMPOSE_PROJECT_NAME}_" || true)
  if [[ -n "${nets:-}" ]]; then run docker network rm ${nets}; else echo "(none)"; fi
}
up_db() { echo "â–¶ï¸  Starting DB (kc_postgres)â€¦"; run c up -d kc_postgres; }
up_kc_importer() {
  echo "â–¶ï¸  Building keycloak-seed imageâ€¦"
  run c build --no-cache keycloak-seed
  echo "â–¶ï¸  Recreating kc-importerâ€¦"
  run c up --force-recreate kc-importer
}

up_kc_post_import(){ echo "â–¶ï¸  Recreating kc-post-importâ€¦"; run c up --force-recreate kc-post-import; }
up_keycloak(){
  echo "â–¶ï¸  Building keycloak imageâ€¦"
  run c build --no-cache keycloak
  echo "â–¶ï¸  Starting Keycloakâ€¦";
  run c up -d keycloak;
}

up_kc_verify(){ echo "â–¶ï¸  Running kc-verifyâ€¦"; run c up --force-recreate kc-verify; }
full_repair(){ down_seed; kill_leftovers; prune_networks; rm_osss_networks; up_db; up_kc_importer; echo "âœ… Full repair sequence finished."; }
show_status(){
  echo "â–¶ï¸  Containers (project ${COMPOSE_PROJECT_NAME}):"
  docker ps -a --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" \
    --format 'table {{.Names}}\t{{.Status}}\t{{.Networks}}'
  echo; echo "â–¶ï¸  Networks containing '${COMPOSE_PROJECT_NAME}_':"
  docker network ls | (head -n1; grep -E "^.* ${COMPOSE_PROJECT_NAME}_" || true)
}

# -------- logs helpers (enhanced) --------
# 1) Always list services from the COMPOSE FILE (even if never started)
list_services() {
  if c config --services >/dev/null 2>&1; then
    c config --services | sed '/^\s*$/d' | sort -u
  else
    # Fallback: try to infer from docker ps name pattern
    docker ps -a --format '{{.Names}}' \
      | sed -n "s/^${COMPOSE_PROJECT_NAME}-\([a-zA-Z0-9_.-]\+\)-[0-9]\+$/\1/p" \
      | sort -u
  fi
}

# 2) Resolve the most recent container ID for a given service (running or exited)
last_container_id() {
  local svc="$1"
  # filter by compose project+service labels, then pick newest by Created timestamp
  local ids created id newest created_newest
  mapfile -t ids < <(docker ps -a \
    --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" \
    --filter "label=com.docker.compose.service=${svc}" \
    --format '{{.ID}}')
  newest=""
  created_newest=""
  for id in "${ids[@]:-}"; do
    created=$(docker inspect -f '{{.Created}}' "$id" 2>/dev/null || true)
    [[ -z "$created" ]] && continue
    if [[ -z "$created_newest" || "$created" > "$created_newest" ]]; then
      created_newest="$created"; newest="$id"
    fi
  done
  [[ -n "$newest" ]] && echo "$newest"
}

print_last_run_details() {
  local svc="$1" cid
  cid=$(last_container_id "$svc" || true)
  if [[ -z "${cid}" ]]; then
    echo "(no container history for service '$svc' in project '${COMPOSE_PROJECT_NAME}')"
    return 1
  fi
  docker inspect -f $'Service: %s\nContainer: %s\nImage: %s\nCreated: %s\nState: %s\nStarted: %s\nFinished: %s\nExitCode: %d\nOOMKilled: %t\nRestartCount: %d' \
    "$svc" "$cid" \
    | sed "1s/${svc}/${svc}/" 2>/dev/null || {
      # Portable variant if the multi-arg format fails (older docker):
      docker inspect --format $'Service: %s\nContainer: %s\nImage: %s\nCreated: %s\nState: %s\nStarted: %s\nFinished: %s\nExitCode: %d\nOOMKilled: %t\nRestartCount: %d' \
        $(echo "$svc" "$cid" | xargs -n1) 2>/dev/null || true
    }
  # Alternative robust one-field-at-a-time (always works):
  echo "Service: $svc"
  docker inspect -f $'Container: {{.Name}}\nImage: {{.Config.Image}}\nCreated: {{.Created}}\nState: {{.State.Status}}\nStarted: {{.State.StartedAt}}\nFinished: {{.State.FinishedAt}}\nExitCode: {{.State.ExitCode}}\nOOMKilled: {{.State.OOMKilled}}\nRestartCount: {{.RestartCount}}' "$cid"
}

# 3) Tail logs for a service. Try compose logs first; if that fails, tail the last container logs.
logs_tail_service_any(){
  local svc="$1" lines="${2:-$DEFAULT_TAIL}" rc=0
  [[ "$lines" =~ ^[0-9]+$ ]] || lines="$DEFAULT_TAIL"
  echo "ðŸ“œ Last ${lines} lines for '${svc}':"
  set +e
  c logs --no-color --tail "$lines" "$svc" 2>&1
  rc=$?
  set -e
  if (( rc != 0 )); then
    local cid
    cid=$(last_container_id "$svc" || true)
    if [[ -n "$cid" ]]; then
      echo "(compose logs unavailable; showing last container $cid)"
      docker logs --tail "$lines" "$cid" || true
    else
      echo "(no logs found for service '$svc')"
    fi
  fi
}

logs_follow_service_any(){
  local svc="$1" rc=0
  echo "ðŸ“œ Following logs for '${svc}'. Press Ctrl-C to return."
  trap 'echo; echo "â†© Back to logs menu"; trap - INT; return 0' INT
  set +e
  c logs -f --tail "$DEFAULT_TAIL" "$svc"
  rc=$?
  set -e
  if (( rc != 0 )); then
    local cid
    cid=$(last_container_id "$svc" || true)
    if [[ -n "$cid" ]]; then
      echo "(compose stream unavailable; following last container $cid)"
      docker logs -f --tail "$DEFAULT_TAIL" "$cid" || true
    else
      echo "(no container found to follow for service '$svc')"
    fi
  fi
  trap - INT
}

logs_tail_all_any(){
  local n="${1:-$DEFAULT_TAIL}"
  [[ "$n" =~ ^[0-9]+$ ]] || n="$DEFAULT_TAIL"
  echo "ðŸ“œ Last ${n} lines for ALL services (including stopped if present):"
  local svc
  while read -r svc; do
    [[ -z "$svc" ]] && continue
    echo "\n===== ${svc} ====="
    logs_tail_service_any "$svc" "$n" || true
  done < <(list_services)
}

shortcut_if_exists(){
  local svc="$1" action="$2" lines="${3:-$DEFAULT_TAIL}"
  if list_services | grep -qx "$svc"; then
    case "$action" in
      follow) logs_follow_service_any "$svc" ;;
      tail)   logs_tail_service_any   "$svc" "$lines" ;;
      *) echo "unknown action $action" ;;
    esac
  else
    echo "Service '$svc' not present in compose config (project/profile)."
  fi
}

set_default_tail(){
  local n
  read -rp "Enter default tail size (current ${DEFAULT_TAIL}): " n || return 0
  [[ "$n" =~ ^[0-9]+$ ]] || { echo "Not a number."; return 1; }
  DEFAULT_TAIL="$n"
  save_config
}

# -------- logs submenu --------
logs_menu() {
  local tail_n="${TAIL:-$DEFAULT_TAIL}"
  local choice svc_count svc

  _print_services() {
    local i=0
    mapfile -t __SERVICES < <(list_services | sed '/^\s*$/d')
    svc_count="${#__SERVICES[@]}"
    if (( svc_count == 0 )); then
      echo "No services found (project: ${COMPOSE_PROJECT_NAME})."
      return 1
    fi
    echo "Available services:"
    for ((i=0; i<svc_count; i++)); do
      printf "  %2d) %s\n" "$((i+1))" "${__SERVICES[$i]}"
    done
    return 0
  }

  while true; do
    echo
    echo "==== Logs Menu ===="
    echo "Enter a number to follow that service's logs."
    echo "a) follow ALL services (compose)"
    echo "t) tail ALL services (with fallback)"
    echo "d) last-run details for a service"
    echo "b) back   r) refresh   q) quit"
    echo "Tail lines: ${tail_n}"
    echo

    _print_services || { echo "Press b to go back, or q to quit."; }

    read -rp "Choice: " choice || return 0
    case "$choice" in
      b|B) return 0 ;;
      q|Q) echo "Bye!"; exit 0 ;;
      r|R) continue ;;
      a|A)
        echo "Following logs for ALL services via compose (Ctrl-C to return)â€¦"
        ( trap - INT; c logs -f --tail "$tail_n" ) || true
        ;;
      t|T)
        logs_tail_all_any "$tail_n"
        ;;
      d|D)
        echo "Enter service name for last-run details (or number):"
        read -r svc || continue
        if [[ "$svc" =~ ^[0-9]+$ ]]; then
          mapfile -t __SERVICES < <(list_services)
          (( svc>=1 && svc<=${#__SERVICES[@]} )) && svc="${__SERVICES[$((svc-1))]}"
        fi
        print_last_run_details "$svc" || true
        ;;
      ''|*[!0-9]*)
        echo "Unknown choice: ${choice}"
        ;;
      *)
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
          echo "Unknown choice: ${choice}"
          continue
        fi
        if (( choice < 1 || choice > svc_count )); then
          echo "Invalid number: ${choice}"
          continue
        fi
        svc="${__SERVICES[$((choice-1))]}"
        echo "Following logs for service: ${svc} (Ctrl-C to return to logs menu)â€¦"
        ( trap - INT; logs_follow_service_any "$svc" ) || true
        ;;
    esac
  done
}

# -------- main menu --------
menu() {
  while true; do
    echo
    echo "==============================================="
    echo " Compose Repair Menu (project: ${COMPOSE_PROJECT_NAME})"
    echo " File: ${COMPOSE_FILE}   Profile: ${PROFILE}"
    echo "==============================================="
    echo " 1) Down ${PROFILE} profile (remove-orphans, volumes)"
    echo " 2) Remove leftover containers for project"
    echo " 3) Prune dangling networks"
    echo " 4) Remove '${COMPOSE_PROJECT_NAME}_â€¦' networks"
    echo " 5) Up DB only (kc_postgres)"
    echo " 6) Recreate kc-importer"
    echo " 7) Recreate kc-post-import"
    echo " 8) Full repair (1â†’4â†’5â†’6)"
    echo " 9) Show status"
    echo "10) Start Keycloak"
    echo "11) Run kc-verify"
    echo " L) Logs submenu"
    echo " q) Quit"
    echo "-----------------------------------------------"
    read -rp "Select an option: " ans || exit 0
    case "${ans}" in
      1) down_seed ;;
      2) kill_leftovers ;;
      3) prune_networks ;;
      4) rm_osss_networks ;;
      5) up_db ;;
      6) up_kc_importer ;;
      7) up_kc_post_import ;;
      8) full_repair ;;
      9) show_status ;;
      10) up_keycloak ;;
      11) up_kc_verify ;;
      l|L) logs_menu ;;
      q|Q) echo "Bye!"; exit 0 ;;
      *) echo "Unknown choice: ${ans}" ;;
    esac
  done
}

menu
