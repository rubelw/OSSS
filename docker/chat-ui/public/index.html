<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Local Chat UI (safe use)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, "Segoe UI", Arial; background:#f6f7fb; color:#111; margin:0; padding:0; display:flex; height:100vh; }
    .app { margin:auto; width:860px; max-width:96%; background:white; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.08); overflow:hidden; display:flex; flex-direction:column; min-height:620px; }
    header { padding:14px 18px; border-bottom:1px solid #eee; font-weight:600; display:flex; justify-content:space-between; align-items:center; }
    .meta { font-size:12px; color:#666; padding:8px 16px; border-bottom:1px solid #f1f1f1; background:#fbfcff; }
    .messages { padding:16px; flex:1; overflow:auto; background:#fff; }
    .msg { margin:10px 0; display:flex; gap:8px; }
    .msg.user { justify-content:flex-end; }
    .bubble { max-width:75%; padding:10px 14px; border-radius:12px; line-height:1.45; }
    .bubble.user { background:#2b6ef6; color:white; border-bottom-right-radius:4px; }
    .bubble.bot { background:#f1f3f5; color:#111; border-bottom-left-radius:4px; }
    .toolbar { display:flex; gap:10px; align-items:center; padding:10px 16px; border-bottom:1px solid #eee; background:#fafbff; flex-wrap:wrap; }
    .toolbar select, .toolbar input[type="text"], .toolbar input[type="number"] { padding:6px 8px; border:1px solid #ddd; border-radius:8px; font-size:13px; }
    .toolbar label { font-size:12px; color:#555; display:flex; gap:6px; align-items:center; }
    .quick { display:flex; gap:8px; flex-wrap:wrap; margin-left:auto; }
    .quick button { background:#eef2ff; color:#2b3a67; border:1px solid #e3e7fd; padding:6px 8px; border-radius:8px; cursor:pointer; font-size:12px; }
    .composer { padding:12px; border-top:1px solid #eee; display:flex; gap:8px; }
    textarea { flex:1; padding:10px; min-height:56px; resize:vertical; border-radius:8px; border:1px solid #ddd; font-size:14px; }
    button.primary { background:#2b6ef6; color:white; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; }
    footer { font-size:12px; color:#777; padding:8px 12px; text-align:center; }
    code.inline { background:#f3f4f6; padding:2px 6px; border-radius:6px; border:1px solid #eee; }
    pre { background:#0b1020; color:#eaeefc; padding:12px; border-radius:10px; overflow:auto; font-size:12.5px; }
    .sep { width:1px; height:22px; background:#e5e7eb; margin:0 6px; }
  </style>
  <!-- Client-side Markdown renderer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div>Local Chat UI ‚Äî Use responsibly</div>
      <div style="font-size:12px;color:#666;">
        Backends:
        <code class="inline">LLM</code> ‚Ä¢
        <code class="inline">Rasa Chat</code> ‚Ä¢
        <code class="inline">Rasa Parse</code> ‚Ä¢
        <code class="inline">Tutor (FastAPI)</code>
      </div>
    </header>

    <div class="meta">
      Connected to local proxies:
      <code class="inline">/v1/chat/safe</code>,
      <code class="inline">/rasa/chat</code>,
      <code class="inline">/rasa/parse</code>,
      <code class="inline">/tutor/tutors</code>,
      This UI must not be used for targeted political persuasion or harassment.
    </div>

    <div class="toolbar">
      <label>
        Backend
        <select id="backend">
          <option value="llm">LLM (OpenAI-compatible)</option>
          <option value="rasa-chat">Rasa Chat</option>
          <option value="rasa-parse">Rasa Parse (NLU)</option>
          <option value="tutor">Tutor (FastAPI)</option>
        </select>
      </label>

      <span class="sep"></span>

      <label title="Sender id passed to Rasa Chat">
        Sender
        <input id="sender" type="text" placeholder="user" style="width:140px"/>
      </label>

      <!-- DEFAULT: checked -->
      <label title="Ask server to render HTML/Markdown">
        <input id="asHtml" type="checkbox" checked/> Render as HTML/Markdown
      </label>

      <span class="sep"></span>

      <!-- Tutors controls (shown only when backend === tutor) -->
      <label id="tutorWrap" style="display:none;">
        Tutor
        <select id="tutorId" style="min-width:160px"></select>
      </label>
      <button id="refreshTutors" type="button" style="display:none;">‚Üª</button>
      <label id="ragWrap" style="display:none;" title="Whether to use RAG for this request">
        <input id="useRag" type="checkbox"/> Use RAG
      </label>
      <label id="tokensWrap" style="display:none;" title="Max tokens for tutor response">
        Max tokens
        <input id="maxTokens" type="number" value="128" min="1" step="1" style="width:80px"/>
      </label>

      <div class="quick">
        <button id="generalBtn" type="button" data-example="Hello!">üí¨ General Chat</button>
        <button id="careerBtn" type="button" data-example="start career mentor">üéì Career Mentor</button>
        <button id="math8Btn" type="button" data-example="How to add 1 + 1">üìê Math Tutor</button>
      </div>
    </div>

    <div id="messages" class="messages" aria-live="polite"></div>

    <div class="composer">
      <textarea id="input" placeholder="Type your message‚Ä¶ (Ctrl/Cmd+Enter to send)"></textarea>
      <button id="send" class="primary">Send</button>
    </div>

    <footer>Local model proxy ‚Äî for experimentation and allowed use only.</footer>
  </div>

<script>
  const TUTOR_API_BASE = "/tutor";
  const messagesEl = document.getElementById("messages");
  const inputEl = document.getElementById("input");
  const sendBtn = document.getElementById("send");
  const backendEl = document.getElementById("backend");
  const senderEl = document.getElementById("sender");
  const asHtmlEl = document.getElementById("asHtml");

  const tutorWrap = document.getElementById("tutorWrap");
  const tutorIdEl = document.getElementById("tutorId");
  const refreshTutorsBtn = document.getElementById("refreshTutors");
  const ragWrap = document.getElementById("ragWrap");
  const useRagEl = document.getElementById("useRag");
  const tokensWrap = document.getElementById("tokensWrap");
  const maxTokensEl = document.getElementById("maxTokens");

  const chatHistory = []; // [{role:'user'|'assistant', content:'...'}]




  // Force default ON at startup
  asHtmlEl.checked = true;

  // Convert Markdown -> HTML (safe-ish; relies on marked)
  function mdToHtml(s) {
    try {
      if (typeof s !== "string") return s;
      if (window.marked && typeof window.marked.parse === "function") {
        return window.marked.parse(s);
      }
      // ultra-minimal fallback
      return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\n/g,"<br/>");
    } catch {
      return s;
    }
  }

  // Quick buttons behavior (single handler each)
  document.querySelectorAll(".quick button").forEach(b => {
    b.addEventListener("click", () => {
      if (b.id === "math8Btn") return; // handled separately
      inputEl.value = b.getAttribute("data-example") || "";
      inputEl.focus();
      if (b.id === "careerBtn") backendEl.value = "rasa-chat";
      if (b.id === "generalBtn") backendEl.value = "llm";
    });
  });

  // Math8 example: fill only (no auto-send)
  document.getElementById("math8Btn").addEventListener("click", async () => {
    backendEl.value = "tutor";
    showTutorControls(true);

    const needsLoad = !tutorIdEl.options.length || (tutorIdEl.options.length === 1 && !tutorIdEl.value);
    if (needsLoad) await loadTutors();

    const math8 = Array.from(tutorIdEl.options).find(o => (o.value || "").toLowerCase() === "math8");
    if (math8) tutorIdEl.value = math8.value;

    useRagEl.checked = false;
    maxTokensEl.value = 128;

    inputEl.value = "How to add 1 + 1";
    inputEl.focus();
  });

  function appendMessage(content, who, isHtml=false) {
    const wrapper = document.createElement("div");
    wrapper.className = "msg " + (who==="user" ? "user" : "bot");
    const bubble = document.createElement("div");
    bubble.className = "bubble " + (who==="user" ? "user" : "bot");
    if (isHtml) {
      bubble.innerHTML = content;
    } else if (typeof content === "object") {
      bubble.innerHTML = "<pre>"+escapeHtml(JSON.stringify(content, null, 2))+"</pre>";
    } else {
      bubble.textContent = content;
    }
    wrapper.appendChild(bubble);
    messagesEl.appendChild(wrapper);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function escapeHtml(s){
    return String(s)
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
  }

  function showTutorControls(show) {
    tutorWrap.style.display = show ? "" : "none";
    refreshTutorsBtn.style.display = show ? "" : "none";
    ragWrap.style.display = show ? "" : "none";
    tokensWrap.style.display = show ? "" : "none";
  }

  backendEl.addEventListener("change", async () => {
    const isTutor = backendEl.value === "tutor";
    showTutorControls(isTutor);
    if (isTutor) {
      const needsLoad = !tutorIdEl.options.length || (tutorIdEl.options.length === 1 && !tutorIdEl.value);
      if (needsLoad) await loadTutors();
    }
  });

  async function loadTutors() {
    try {
      const resp = await fetch(`${TUTOR_API_BASE}/tutors`);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const list = await resp.json();

      tutorIdEl.innerHTML = "";
      if (!Array.isArray(list) || list.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no tutors found)";
        tutorIdEl.appendChild(opt);
        return false;
      }

      for (const t of list) {
        const id = t.tutor_id || t.id || t.name || "";
        if (!id) continue;
        const label = t.title ? `${id} ‚Äî ${t.title}` : id;
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = label;
        tutorIdEl.appendChild(opt);
      }

      const math8 = Array.from(tutorIdEl.options).find(o => (o.value || "").toLowerCase() === "math8");
      tutorIdEl.value = math8 ? math8.value : tutorIdEl.options[0].value;
      return true;
    } catch (e) {
      tutorIdEl.innerHTML = "";
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(failed to load tutors)";
      tutorIdEl.appendChild(opt);
      console.error(e);
      return false;
    }
  }

  refreshTutorsBtn.addEventListener("click", loadTutors);

  // Re-entrancy guard
  let sending = false;

  async function send() {
      if (sending) return;
      const text = inputEl.value.trim();
      if (!text) return;

      sending = true;
      const backend = backendEl.value;
      const sender = (senderEl.value || "user").trim();
      const wantHtml = asHtmlEl.checked;

      appendMessage(text, "user");
      chatHistory.push({ role: "user", content: text });
      inputEl.value = "";
      sendBtn.disabled = true;

      try {
        let url = "";
        let body = null;
        const headers = { "Content-Type": "application/json" };
        headers["Accept"] = wantHtml ? "text/html" : "application/json";

        if (backend === "llm") {
          // Hit FastAPI directly (avoid node proxy 404 on /v1/chat/safe)
          url = `/v1/chat/safe`;
          headers["Accept"] = "application/json"; // force JSON; we render markdown client-side
          const hasSystem = chatHistory.some(m => m.role === "system");
          const messages = (hasSystem ? [] : [{ role: "system", content: "You are a helpful assistant." }])
            .concat(chatHistory);
          body = { model: "llama3.1", messages, temperature: 0.2, max_tokens: 256, stream: false };

        } else if (backend === "rasa-chat") {
          url = "/rasa/chat";
          body = { sender, message: text };

        } else if (backend === "rasa-parse") {
          url = "/rasa/parse";
          body = { text };

        } else if (backend === "tutor") {
          const needsLoad = !tutorIdEl.options.length || (tutorIdEl.options.length === 1 && !tutorIdEl.value);
          if (needsLoad) await loadTutors();
          const selected = tutorIdEl.value;
          if (!selected) {
            appendMessage("(No tutor available ‚Äî open /tutor/tutors to verify, then click ‚Üª)", "bot");
            return;
          }
          url = `${TUTOR_API_BASE}/tutors/${encodeURIComponent(selected)}/chat`;
          body = {
            message: text,
            history: chatHistory.filter(m => m.role !== "system").slice(0, -1),
            use_rag: !!useRagEl.checked,
            max_tokens: Number(maxTokensEl.value) || 128
          };
        }

        const resp = await fetch(url, { method: "POST", headers, body: JSON.stringify(body) });

        const isOK = resp.ok;
        const contentType = (resp.headers.get("content-type") || "").toLowerCase();

        // If server sent ready-made HTML, render as-is
        if (wantHtml && contentType.includes("text/html")) {
          const html = await resp.text();
          appendMessage(html || "<em>(empty)</em>", "bot", true);
          return;
        }

        // Parse once
        const textBody = await resp.text();
        let payload = null;
        try { payload = JSON.parse(textBody); } catch { /* leave as text */ }

        if (!isOK) {
          const reason =
            payload?.detail?.reason ||
            payload?.detail ||
            payload ||
            textBody ||
            ("HTTP " + resp.status);
          appendMessage(typeof reason === "string" ? reason : JSON.stringify(reason, null, 2), "bot");
          return;
        }

        // Success handling per backend
        if (backend === "llm") {
          const reply =
            payload?.message?.content ??                       // FastAPI /v1/chat/safe
            payload?.choices?.[0]?.message?.content ??         // OpenAI-like
            payload?.choices?.[0]?.text ??                     // some OSS
            payload?.result?.[0]?.content ??                   // others
            (typeof payload === "string" ? payload : JSON.stringify(payload ?? textBody, null, 2));

          const out = wantHtml ? mdToHtml(reply) : reply;
          appendMessage(out, "bot", wantHtml);
          chatHistory.push({ role: "assistant", content: reply });
          return;
        }

        if (backend === "rasa-chat") {
          let combined;
          if (Array.isArray(payload)) {
            combined = payload.map(m => m.text || m.image || m.custom || "")
                              .filter(Boolean)
                              .join("\n\n");
          } else {
            combined = typeof payload === "string" ? payload : (textBody || "");
          }
          const out = wantHtml ? mdToHtml(combined) : combined;
          appendMessage(out, "bot", wantHtml);
          if (combined) chatHistory.push({ role: "assistant", content: combined });
          return;
        }

        if (backend === "rasa-parse") {
          const textOut = typeof payload === "string" ? payload : (textBody || JSON.stringify(payload, null, 2));
          const out = wantHtml ? mdToHtml(textOut) : textOut;
          appendMessage(out, "bot", wantHtml);
          return;
        }

        if (backend === "tutor") {
          if (payload && typeof payload === "object" && ("answer" in payload)) {
            let reply = payload.answer || "";
            if (Array.isArray(payload.sources) && payload.sources.length) {
              reply += "\n\nSources:\n" + payload.sources.map((s, i) =>
                `  ${i+1}. ${s.source || s.file || "doc"} (p${s.page ?? "?"})`
              ).join("\n");
            }
            const out = wantHtml ? mdToHtml(reply) : reply;
            appendMessage(out, "bot", wantHtml);
            chatHistory.push({ role: "assistant", content: payload.answer || "" });
          } else {
            const textOut = typeof payload === "string" ? payload : (textBody || JSON.stringify(payload, null, 2));
            const out = wantHtml ? mdToHtml(textOut) : textOut;
            appendMessage(out, "bot", wantHtml);
          }
          return;
        }

      } catch (err) {
        appendMessage("Network error: " + String(err), "bot");
      } finally {
        sendBtn.disabled = false;
        sending = false;
      }
  }


  sendBtn.addEventListener("click", send);
  inputEl.addEventListener("keydown", (e) => { if(e.key === "Enter" && (e.ctrlKey || e.metaKey)) send(); });

  // Initial setup
  showTutorControls(false);
  loadTutors(); // preload tutors
</script>
</body>
</html>
